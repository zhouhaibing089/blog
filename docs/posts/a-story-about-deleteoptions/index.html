<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>A Story about DeleteOptions | Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.111.3">
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.4fc0b62e4b82c997bb0041217cd6b979.css" rel="stylesheet">
    

    
      <link rel="stylesheet" href="/css/custom.css">
    
      <link rel="stylesheet" href="/css/syntax.css">
    

    
      

    

    
    
    <meta property="og:title" content="A Story about DeleteOptions" />
<meta property="og:description" content="Note: The issue has been fixed in https://github.com/kubernetes/kubernetes/pull/76051.
Today, I want to share a story about object deletion in kubernetes federation. This leads to a better understanding on how object deletion works in kubernetes, and I believe this may help others to understand it as well.
It all starts with a support request:
When I delete my namespace on federation, the same namespace in member cluster is not deleted, however, cascade deletion does happen for all other resources like configmaps." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.zhouhaibing.com/posts/a-story-about-deleteoptions/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-30T09:27:34-07:00" />
<meta property="article:modified_time" content="2019-03-30T09:27:34-07:00" />
<meta itemprop="name" content="A Story about DeleteOptions">
<meta itemprop="description" content="Note: The issue has been fixed in https://github.com/kubernetes/kubernetes/pull/76051.
Today, I want to share a story about object deletion in kubernetes federation. This leads to a better understanding on how object deletion works in kubernetes, and I believe this may help others to understand it as well.
It all starts with a support request:
When I delete my namespace on federation, the same namespace in member cluster is not deleted, however, cascade deletion does happen for all other resources like configmaps."><meta itemprop="datePublished" content="2019-03-30T09:27:34-07:00" />
<meta itemprop="dateModified" content="2019-03-30T09:27:34-07:00" />
<meta itemprop="wordCount" content="1613">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="A Story about DeleteOptions"/>
<meta name="twitter:description" content="Note: The issue has been fixed in https://github.com/kubernetes/kubernetes/pull/76051.
Today, I want to share a story about object deletion in kubernetes federation. This leads to a better understanding on how object deletion works in kubernetes, and I believe this may help others to understand it as well.
It all starts with a support request:
When I delete my namespace on federation, the same namespace in member cluster is not deleted, however, cascade deletion does happen for all other resources like configmaps."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Blog
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      




  <div id="sharing" class="mt3">

    
    <a href="https://www.facebook.com/sharer.php?u=https://blog.zhouhaibing.com/posts/a-story-about-deleteoptions/" class="facebook no-underline" aria-label="share on Facebook">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765,50.32h6.744V33.998h4.499l0.596-5.624h-5.095  l0.007-2.816c0-1.466,0.14-2.253,2.244-2.253h2.812V17.68h-4.5c-5.405,0-7.307,2.729-7.307,7.317v3.377h-3.369v5.625h3.369V50.32z   M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;"/></svg>

    </a>

    
    
    <a href="https://twitter.com/share?url=https://blog.zhouhaibing.com/posts/a-story-about-deleteoptions/&amp;text=A%20Story%20about%20DeleteOptions" class="twitter no-underline" aria-label="share on Twitter">
      <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

    </a>

    
    <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https://blog.zhouhaibing.com/posts/a-story-about-deleteoptions/&amp;title=A%20Story%20about%20DeleteOptions" class="linkedin no-underline" aria-label="share on LinkedIn">
      <svg  height="32px"  style="enable-background:new 0 0 65 65;" version="1.1" viewBox="0 0 65 65" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M50.837,48.137V36.425c0-6.275-3.35-9.195-7.816-9.195  c-3.604,0-5.219,1.983-6.119,3.374V27.71h-6.79c0.09,1.917,0,20.427,0,20.427h6.79V36.729c0-0.609,0.044-1.219,0.224-1.655  c0.49-1.22,1.607-2.483,3.482-2.483c2.458,0,3.44,1.873,3.44,4.618v10.929H50.837z M22.959,24.922c2.367,0,3.842-1.57,3.842-3.531  c-0.044-2.003-1.475-3.528-3.797-3.528s-3.841,1.524-3.841,3.528c0,1.961,1.474,3.531,3.753,3.531H22.959z M34,64  C17.432,64,4,50.568,4,34C4,17.431,17.432,4,34,4s30,13.431,30,30C64,50.568,50.568,64,34,64z M26.354,48.137V27.71h-6.789v20.427  H26.354z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/>
</svg>

    </a>
  </div>


      <h1 class="f1 athelas mt3 mb1">A Story about DeleteOptions</h1>
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-03-30T09:27:34-07:00">March 30, 2019</time>

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p><strong>Note</strong>: The issue has been fixed in <a href="https://github.com/kubernetes/kubernetes/pull/76051">https://github.com/kubernetes/kubernetes/pull/76051</a>.</p>
<p>Today, I want to share a story about object deletion in kubernetes federation.
This leads to a better understanding on how object deletion works in kubernetes,
and I believe this may help others to understand it as well.</p>
<p>It all starts with a support request:</p>
<blockquote>
<p>When I delete my namespace on federation, the same namespace in member cluster
is not deleted, however, cascade deletion does happen for all other resources
like configmaps.</p>
</blockquote>
<p>Let&rsquo;s see how object deletion is supposed to work on federation firstly. I am
going to create a new namespace on federation below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cat ns.yaml
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">kind: Namespace
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">  name: fcp-foo
</span></span><span class="line"><span class="cl">$ kubectl create -f ns.yaml
</span></span><span class="line"><span class="cl">namespace/fcp-foo created
</span></span><span class="line"><span class="cl">$ kubectl get ns fcp-foo -o yaml
</span></span><span class="line"><span class="cl">apiVersion: v1
</span></span><span class="line"><span class="cl">kind: Namespace
</span></span><span class="line"><span class="cl">metadata:
</span></span><span class="line"><span class="cl">  creationTimestamp: <span class="s2">&#34;2019-03-31T03:56:32Z&#34;</span>
</span></span><span class="line"><span class="cl">  finalizers:
</span></span><span class="line"><span class="cl">  - federation.kubernetes.io/delete-from-underlying-clusters
</span></span><span class="line"><span class="cl">  - orphan
</span></span><span class="line"><span class="cl">  name: fcp-foo
</span></span><span class="line"><span class="cl">  resourceVersion: <span class="s2">&#34;52956073&#34;</span>
</span></span><span class="line"><span class="cl">  selfLink: /api/v1/namespaces/fcp-foo
</span></span><span class="line"><span class="cl">  uid: f8b3ea79-5368-11e9-bc0b-2e8a8f1a8f3c
</span></span><span class="line"><span class="cl">spec:
</span></span><span class="line"><span class="cl">  finalizers:
</span></span><span class="line"><span class="cl">  - kubernetes
</span></span><span class="line"><span class="cl">status:
</span></span><span class="line"><span class="cl">  phase: Active
</span></span></code></pre></div><p>If you pay attention enough, you can find that there are two finalizers added:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">finalizers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="l">federation.kubernetes.io/delete-from-underlying-clusters</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="l">orphan</span><span class="w">
</span></span></span></code></pre></div><p>Finalizer is the mechanism to ensure proper cleanup in kubernetes, the object
won&rsquo;t disappear from storage as long as there are finalizers remaining. In
another word, every finalizer has its own responsibility for certain resource
cleanup. What is the responsibility of these two finalizers then? Let&rsquo;s take a
look at the <a href="https://github.com/kubernetes/federation/blob/804bb9f3599b9b4c7eb29384921b0bd31cd66de8/pkg/federation-controller/util/deletionhelper/deletion_helper.go#L67-L98">code</a> where these two finalizers are added.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Ensures that the given object has both FinalizerDeleteFromUnderlyingClusters
</span></span></span><span class="line"><span class="cl"><span class="c1">// and FinalizerOrphan finalizers.
</span></span></span><span class="line"><span class="cl"><span class="c1">// We do this so that the controller is always notified when a federation resource is deleted.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If user deletes the resource with nil DeleteOptions or
</span></span></span><span class="line"><span class="cl"><span class="c1">// DeletionOptions.OrphanDependents = true then the apiserver removes the orphan finalizer
</span></span></span><span class="line"><span class="cl"><span class="c1">// and deletion helper does a cascading deletion.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, deletion helper just removes the federation resource and orphans
</span></span></span><span class="line"><span class="cl"><span class="c1">// the corresponding resources in underlying clusters.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This method should be called before creating objects in underlying clusters.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dh</span> <span class="o">*</span><span class="nx">DeletionHelper</span><span class="p">)</span> <span class="nf">EnsureFinalizers</span><span class="p">(</span><span class="nx">obj</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">Object</span><span class="p">)</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nx">Object</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">finalizers</span> <span class="o">:=</span> <span class="nx">sets</span><span class="p">.</span><span class="nx">String</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hasFinalizer</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">finalizersutil</span><span class="p">.</span><span class="nf">HasFinalizer</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">FinalizerDeleteFromUnderlyingClusters</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">hasFinalizer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">finalizers</span><span class="p">.</span><span class="nf">Insert</span><span class="p">(</span><span class="nx">FinalizerDeleteFromUnderlyingClusters</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hasFinalizer</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">finalizersutil</span><span class="p">.</span><span class="nf">HasFinalizer</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">FinalizerOrphanDependents</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">hasFinalizer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">finalizers</span><span class="p">.</span><span class="nf">Insert</span><span class="p">(</span><span class="nx">metav1</span><span class="p">.</span><span class="nx">FinalizerOrphanDependents</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">finalizers</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">glog</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;Adding finalizers %v to %s&#34;</span><span class="p">,</span> <span class="nx">finalizers</span><span class="p">.</span><span class="nf">List</span><span class="p">(),</span> <span class="nx">dh</span><span class="p">.</span><span class="nf">objNameFunc</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">dh</span><span class="p">.</span><span class="nf">addFinalizers</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">finalizers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">obj</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>To summarize, the finalizer <code>federation.kubernetes.io/delete-from-underlying-clusters</code>
ensures a proper cleanup in member clusters, aka cascade deletion. However, we
do not always want to do cascade deletion, in some cases, we just want the object
to be deleted from federation while leaving the objects in member clusters intact.</p>
<p>Now the questions is: how does the controller known whether the object needs a
cascade deletion or not? This is where finalizer <code>orphan</code> plays the role. If the
finalizer <code>orphan</code> remains, it means no cascade deletion.</p>
<p>We can also look into the <a href="https://github.com/kubernetes/federation/blob/804bb9f3599b9b4c7eb29384921b0bd31cd66de8/pkg/federation-controller/util/deletionhelper/deletion_helper.go#L110-L129">code</a> where the controller removes finalizers:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Deletes the resources corresponding to the given federated resource from
</span></span></span><span class="line"><span class="cl"><span class="c1">// all underlying clusters, unless it has the FinalizerOrphan finalizer.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Removes FinalizerOrphan and FinalizerDeleteFromUnderlyingClusters finalizers
</span></span></span><span class="line"><span class="cl"><span class="c1">// when done.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Callers are expected to keep calling this (with appropriate backoff) until
</span></span></span><span class="line"><span class="cl"><span class="c1">// it succeeds.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">dh</span> <span class="o">*</span><span class="nx">DeletionHelper</span><span class="p">)</span> <span class="nf">HandleObjectInUnderlyingClusters</span><span class="p">(</span><span class="nx">obj</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">Object</span><span class="p">)</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hasFinalizer</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">finalizersutil</span><span class="p">.</span><span class="nf">HasFinalizer</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">FinalizerDeleteFromUnderlyingClusters</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">hasFinalizer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">glog</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;obj does not have %s finalizer. Nothing to do&#34;</span><span class="p">,</span> <span class="nx">FinalizerDeleteFromUnderlyingClusters</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">obj</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">hasOrphanFinalizer</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">finalizersutil</span><span class="p">.</span><span class="nf">HasFinalizer</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">FinalizerOrphanDependents</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">obj</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">hasOrphanFinalizer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">glog</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;Found finalizer orphan. Nothing to do, just remove the finalizer&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// If the obj has FinalizerOrphan finalizer, then we need to orphan the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// corresponding objects in underlying clusters.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Just remove both the finalizers in that case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">finalizers</span> <span class="o">:=</span> <span class="nx">sets</span><span class="p">.</span><span class="nf">NewString</span><span class="p">(</span><span class="nx">FinalizerDeleteFromUnderlyingClusters</span><span class="p">,</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">FinalizerOrphanDependents</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">dh</span><span class="p">.</span><span class="nf">removeFinalizers</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">finalizers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span></code></pre></div><p>We can see,  the controller removes both <code>orphan</code> and
<code>federation.kubernetes.io/delete-from-underlying-clusters</code> finalizer at the same
time if <code>orphan</code> finalizer is still on that object.</p>
<p>You may ask, why the controller adds these two finalizers at the first time, does
that mean it will always do non-cascade deletion? The logic seems to be weird,
but actually it is not, just keep reading..</p>
<p>Let&rsquo;s try to convince ourselves first, if we want to do cascade deletion, then
someone must remove the <code>orphan</code> finalizer before the controller works on that
deletion. That has to happen, and must always happen earlier than the time when
controller gets the deletion event.</p>
<p>This proves to be true, when we send a delete request to api server, the
<a href="https://github.com/kubernetes/kubernetes/blob/afefc0b2c587302034993d381f1c7cfa5c38aa9f/pkg/registry/core/namespace/storage/storage.go#L124-L223">registry implementation</a> for namespace decides what to do on those finalizers:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Delete enforces life-cycle rules for namespace termination
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">REST</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">options</span> <span class="o">*</span><span class="nx">metav1</span><span class="p">.</span><span class="nx">DeleteOptions</span><span class="p">)</span> <span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">Object</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// upon first request to delete, we switch the phase to start namespace termination
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// TODO: enhance graceful deletion&#39;s calls to DeleteStrategy to allow phase change and finalizer patterns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">namespace</span><span class="p">.</span><span class="nx">DeletionTimestamp</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nx">Storage</span><span class="p">.</span><span class="nf">GuaranteedUpdate</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ctx</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">preconditions</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">storage</span><span class="p">.</span><span class="nf">SimpleUpdate</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">existing</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">Object</span><span class="p">)</span> <span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">Object</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="o">...</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// Remove orphan finalizer if options.OrphanDependents = false.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">if</span> <span class="nx">options</span><span class="p">.</span><span class="nx">OrphanDependents</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="nx">options</span><span class="p">.</span><span class="nx">OrphanDependents</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// remove Orphan finalizer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">newFinalizers</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">					<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">existingNamespace</span><span class="p">.</span><span class="nx">ObjectMeta</span><span class="p">.</span><span class="nx">Finalizers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">						<span class="nx">finalizer</span> <span class="o">:=</span> <span class="nx">existingNamespace</span><span class="p">.</span><span class="nx">ObjectMeta</span><span class="p">.</span><span class="nx">Finalizers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">						<span class="k">if</span> <span class="nb">string</span><span class="p">(</span><span class="nx">finalizer</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">FinalizerOrphanDependents</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">							<span class="nx">newFinalizers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">newFinalizers</span><span class="p">,</span> <span class="nx">finalizer</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">						<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="p">}</span>
</span></span><span class="line"><span class="cl">					<span class="nx">existingNamespace</span><span class="p">.</span><span class="nx">ObjectMeta</span><span class="p">.</span><span class="nx">Finalizers</span> <span class="p">=</span> <span class="nx">newFinalizers</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="nx">existingNamespace</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span></code></pre></div><p>Bingo, now we can see, the namespace store removes <code>orphan</code> finalizer when
<code>*options.OrphanDependents == false</code>. This can explain how the cascade deletion
works on federation:</p>
<ol>
<li>User sends a delete request via <code>kubectl delete</code>.</li>
<li>APIServer removes the <code>orphan</code> finalizer when <code>options.orphanDependents == false</code>.</li>
<li>Controller then deletes objects in member clusters and removes
<code>federation.kubernetes.io/delete-from-underlying-clusters</code> once all the deletions
are successfully made.</li>
</ol>
<p>If we do not want cascade deletion, we must unset <code>options.orphanDependents</code> or
set it as <code>true</code>. And in that case, the <code>orphan</code> finalizer remains, and the
controller will remove both finalizers without touching member clusters.</p>
<p>Now let&rsquo;s get back to our problem, why it is broken:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="gp">$</span> kubectl delete ns fcp-foo --v<span class="o">=</span><span class="m">10</span>
</span></span><span class="line"><span class="cl"><span class="go">...
</span></span></span><span class="line"><span class="cl"><span class="go">I0330 22:22:08.278004   44597 request.go:942] Request Body: {&#34;propagationPolicy&#34;:&#34;Background&#34;}
</span></span></span><span class="line"><span class="cl"><span class="go">I0330 22:22:08.278049   44597 round_trippers.go:419] curl -k -v -XDELETE  -H &#34;Accept: application/json&#34; -H &#34;Content-Type: application/json&#34; -H &#34;User-Agent: kubectl/v1.14.0 (darwin/amd64) kubernetes/641856d&#34; &#39;https://&lt;apiserver&gt;/api/v1/namespaces/fcp-foo&#39;
</span></span></span><span class="line"><span class="cl"><span class="go">...
</span></span></span></code></pre></div><p>As observed, the delete options is <code>{&quot;propagationPolicy&quot;:&quot;Background&quot;}</code>, this is
the default value on kubectl v1.14.0. Since it does not specifying
<code>orphanDependents</code>, the finalizer <code>orphan</code> is not removed, and thus the cascade
deletion does not happen.</p>
<p>But why other resources like configmaps are still fine, do they have a different
registry store implementation? Well, they do!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Delete removes the item from storage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Store</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">options</span> <span class="o">*</span><span class="nx">metav1</span><span class="p">.</span><span class="nx">DeleteOptions</span><span class="p">)</span> <span class="p">(</span><span class="nx">runtime</span><span class="p">.</span><span class="nx">Object</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Handle combinations of graceful deletion and finalization by issuing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// the correct updates.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">shouldUpdateFinalizers</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nf">deletionFinalizersForGarbageCollection</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">accessor</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// TODO: remove the check, because we support no-op updates now.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">graceful</span> <span class="o">||</span> <span class="nx">pendingFinalizers</span> <span class="o">||</span> <span class="nx">shouldUpdateFinalizers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">err</span><span class="p">,</span> <span class="nx">ignoreNotFound</span><span class="p">,</span> <span class="nx">deleteImmediately</span><span class="p">,</span> <span class="nx">out</span><span class="p">,</span> <span class="nx">lastExisting</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">updateForGracefulDeletionAndFinalizers</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">options</span><span class="p">,</span> <span class="nx">preconditions</span><span class="p">,</span> <span class="nx">obj</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// deletionFinalizersForGarbageCollection analyzes the object and delete options
</span></span></span><span class="line"><span class="cl"><span class="c1">// to determine whether the object is in need of finalization by the garbage
</span></span></span><span class="line"><span class="cl"><span class="c1">// collector. If so, returns the set of deletion finalizers to apply and a bool
</span></span></span><span class="line"><span class="cl"><span class="c1">// indicating whether the finalizer list has changed and is in need of updating.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The finalizers returned are intended to be handled by the garbage collector.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If garbage collection is disabled for the store, this function returns false
</span></span></span><span class="line"><span class="cl"><span class="c1">// to ensure finalizers aren&#39;t set which will never be cleared.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">deletionFinalizersForGarbageCollection</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">e</span> <span class="o">*</span><span class="nx">Store</span><span class="p">,</span> <span class="nx">accessor</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">Object</span><span class="p">,</span> <span class="nx">options</span> <span class="o">*</span><span class="nx">metav1</span><span class="p">.</span><span class="nx">DeleteOptions</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">shouldOrphan</span> <span class="o">:=</span> <span class="nf">shouldOrphanDependents</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">accessor</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newFinalizers</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// first remove both finalizers, add them back if needed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">accessor</span><span class="p">.</span><span class="nf">GetFinalizers</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">f</span> <span class="o">==</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">FinalizerOrphanDependents</span> <span class="o">||</span> <span class="nx">f</span> <span class="o">==</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">FinalizerDeleteDependents</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">newFinalizers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">newFinalizers</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">shouldOrphan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">newFinalizers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">newFinalizers</span><span class="p">,</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">FinalizerOrphanDependents</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// shouldOrphanDependents returns true if the finalizer for orphaning should be set
</span></span></span><span class="line"><span class="cl"><span class="c1">// updated for FinalizerOrphanDependents. In the order of highest to lowest
</span></span></span><span class="line"><span class="cl"><span class="c1">// priority, there are three factors affect whether to add/remove the
</span></span></span><span class="line"><span class="cl"><span class="c1">// FinalizerOrphanDependents: options, existing finalizers of the object,
</span></span></span><span class="line"><span class="cl"><span class="c1">// and e.DeleteStrategy.DefaultGarbageCollectionPolicy.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">shouldOrphanDependents</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">e</span> <span class="o">*</span><span class="nx">Store</span><span class="p">,</span> <span class="nx">accessor</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">Object</span><span class="p">,</span> <span class="nx">options</span> <span class="o">*</span><span class="nx">metav1</span><span class="p">.</span><span class="nx">DeleteOptions</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Get default GC policy from this REST object type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gcStrategy</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">DeleteStrategy</span><span class="p">.(</span><span class="nx">rest</span><span class="p">.</span><span class="nx">GarbageCollectionDeleteStrategy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">defaultGCPolicy</span> <span class="nx">rest</span><span class="p">.</span><span class="nx">GarbageCollectionPolicy</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">defaultGCPolicy</span> <span class="p">=</span> <span class="nx">gcStrategy</span><span class="p">.</span><span class="nf">DefaultGarbageCollectionPolicy</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">defaultGCPolicy</span> <span class="o">==</span> <span class="nx">rest</span><span class="p">.</span><span class="nx">Unsupported</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// return  false to indicate that we should NOT orphan
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// An explicit policy was set at deletion time, that overrides everything
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">options</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">options</span><span class="p">.</span><span class="nx">OrphanDependents</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">*</span><span class="nx">options</span><span class="p">.</span><span class="nx">OrphanDependents</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">options</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">options</span><span class="p">.</span><span class="nx">PropagationPolicy</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="o">*</span><span class="nx">options</span><span class="p">.</span><span class="nx">PropagationPolicy</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">DeletePropagationOrphan</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">DeletePropagationBackground</span><span class="p">,</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">DeletePropagationForeground</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If a finalizer is set in the object, it overrides the default
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// validation should make sure the two cases won&#39;t be true at the same time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">finalizers</span> <span class="o">:=</span> <span class="nx">accessor</span><span class="p">.</span><span class="nf">GetFinalizers</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">finalizers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="nx">f</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">FinalizerOrphanDependents</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">FinalizerDeleteDependents</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Get default orphan policy from this REST object type if it exists
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">defaultGCPolicy</span> <span class="o">==</span> <span class="nx">rest</span><span class="p">.</span><span class="nx">OrphanDependents</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Put it simply:</p>
<ol>
<li>It removes <code>orphan</code> finalizer first.</li>
<li>It adds <code>orphan</code> finalizer back if:
<ol>
<li><code>options.orphanDependents</code> is true.</li>
<li>or <code>options.propagationPolicy</code> is orphan, otherwise not.</li>
<li>options is nil, and <code>orphan</code> finalizer is present.</li>
<li>the default GC policy in DeleteStrategy is <code>OrphanDependents</code></li>
</ol>
</li>
</ol>
<p>Since the client passes delete options as <code>propagationPolicy: background</code>, the
<code>orphan</code> finalizer is not added back, which means the controller will do cascade
deletion.</p>
<p>Now we have figured out how it happened, it needs a lot of patience to go through
the codebase. However it is really enjoyable.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
        <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zhouhaibing089" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://blog.zhouhaibing.com/" >
    &copy;  Blog 2023 
  </a>
    <div>














</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
